[preface]
= Introduction

This book is my second effort at writing down everything I know about APIs. _Build APIs You Wont Hate_ was essentially every complicated design I had to navigate when building an API for a mobile-centric startup that was basically a combination of Foursquare, Groupon, and Instragram. I had to think about naming endpoints, writing documentation for designers, shaping the response body JSON, was curious about which status codes to use, etc.

Then after the initial ebook was released in 2014 I went on to work at a carpooling company that had a few APIs, with folks spread out all over the world. That helped me understand the need for HATEOAS (explained later) a whole lot more, as we were inferring state in all sorts of weird ways and getting it wrong a lot. The folks on that team also helped me learn loads about various forms of integration testing, load testing, standards like JSON:API, and a whole lot more.

The original book was just my attempt to help readers navigate complex decisions, decide between alternative approaches, outline the potential pitfalls of various strategies, etc., but these days when I read things I wrote back then it feels dated. Even though I don't feel like much of it was outright incorrect, I do disagree with many of the conclusions I came to back then. Modern-day Phil writing this in 2019 has a lot more information to go on.

Beyond the gaps in my knowledge, so much has changed in API land between 2014 and 2019. For a while a lot of these changes were incremental and I could just update the book a little for the ebook readers, or expand things with a blog post. Now I feel like the time has come to start from scratch and write a new book, because having people read a whole book then 35+ articles just felt a little silly.

Back in 2014, a lot of folks (myself included) were acting like REST was the only way to do things, and older systems like SOAP (or anything RPC-based) were bad and silly. These days RPC in the form of gRPC or GraphQL is all the rage, and some people are acting like REST is bad and silly. Comically at that time most of us were building "RESTish" APIs anyway due to lack of understanding in the benefits of HATEOAS, and REST without HATEOAS is basically RPC with pretty URLs. When 99% of the API developers out there discuss REST vs RPC it's a fairly moot point, because they're talking about essentially the same thing until they learn the strengths and weakness of both paradigms correctly. This book will help unfurl this mess.

Another huge change in HTTP-land is HTTP/2, and even HTTP/3, changing everything we know about how HTTP works, and how we optimize our APIs to work within the network. Back when I was writing _Build APIs You Wont Hate_, nothing much supported HTTP/2 so it feel more like an academic concept which we could maybe look forward to someday. Now most web servers, several languages, and a whole bunch of frameworks support it, either fully or mostly. The only thing holding API developers back from more usage is education and momentum. HTTP/2 changes pretty much everything about APIs, and changes how you design, build, and interact with everything, as the sort of things you find yourself trying to solve in HTTP/1.1 at the application level are handled seamlessly already in HTTP/2.

In the past a lot of the API specification tools being used for HTTP-based APIs were... fairly bad. Folks were just using them for documentation (if that), and often using annotation-based approaches, because the tooling out there to help design specifications didn't exist. Nobody wants to write a bunch of JSON/YAML by hand, so we just skipped it all, and maybe wrote some docs later, or maybe just didn't bother. Now API Specification tooling has grown so much its almost unrecognizable.

Previously I'd recommend people think about their resources, which helps guide which endpoints we need, then jump right into creating serializers to output data, then we start writing the code to populate those serializers. These days I'd flip that entirely, and start with API specifications first, then use those specifications to build mock servers to get client feedback early, then use those specifications as contracts for contract testing on API responses, and a whole lot more.

So, the times have changed, and the approach for this book will feel a bit different to readers of the last. For example, as well as learning about REST properly (which few books have done in a way easy enough for the majority of developers to understand), we're going to learn about the other two popular technologies: GraphQL and gRPC. Many chapters will be broken down into sections which explain how certain things work for each of these technologies, so you can understand and compare the differences, or skip sections if you are not interested in using those technologies.

Another big difference will be a lack of sample application code. The previous book was basically "How to build RESTish APIs with Laravel" with a lot of theory and occasional code samples for other languages. If you are looking for a "How to build gRPC APIs with Go" or "How to build GraphQL APIs with Erlang" or any other language or technology specific guide, then this book is not going to be for you. We are going to cover REST, gRPC and GraphQL equally, we're going to use examples from various languages, and there will not be a "build along with us as you code" or example application bundled with the book, as they get outdated too fast and keeping book code up to date for a decade is not enjoyable or realistic.

So, settle in, and lets learn a whole bunch of stuff about building APIs!
